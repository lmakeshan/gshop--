# 一、变量的作用域
变量的作用域：```全局变量和局部变量。```
   1.函数内部可以直接读取全局变量
    var n=999;
     
    function f1() {
        alert(n);
    }
     
    f1(); // 999
    ```
    2.函数外部自无法读取函数内的局部变量。
    function f1() {
        var n = 999;
    }
     
    alert(n); // error
# 二、如何从外部读取局部变量？
在函数的内部，```再定义一个函数```
    function f1(){
        var n=999;
        function f2() {
            alert(n); // 999
        }
    }
函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。反过来不行，f2内部的局部变量，对f1 就是不可见的。这是JavaScript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！
    function f1() {
     
        var n = 999;
     
        function f2() {
            alert(n);
        }
     
        return f2;
     
    }
     
    var result = f1();
     
    result(); // 999
# 三、闭包的概念
   f2函数，就是闭包。
闭包就是读取其他函数内部变量的函数。
由于在JavaScript语言中，只有```函数内部的子函数才能读取局部变量```，因此可以把闭包简单理解成"定义在一个函数内部的函数"。

# 四、闭包的用途

闭包可以用在许多地方。它的最大用处有两个，```一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。```
    function f1() {
     
        var n = 999;
     
        nAdd = function () {
            n += 1
        }
     
        function f2() {
            alert(n);
        }
     
        return f2;
     
    }
     
    var result = f1();
     
    result(); // 999
     
    nAdd();
     
    result(); // 1000
##### result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。
##### 这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数），而这个匿名函数本身也是一个闭包，可以在函数外部对函数内部的局部变量进行操作。

js closure
